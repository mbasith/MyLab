#!/usr/bin/env python3
"""
flatten_cmds_keys_root_rule_py3.py

Python 3 ONLY.

- Reads "sample_config".
- Any line with children is a "group"; the last token of each group line is
  bracketed (e.g., dns-server-a -> [dns-server-a]) when used in the path.
- Lines with NO indentation (indent == 0):
    * If they have children -> DO NOT print them alone; they only act as the root group.
    * If they have no children -> Print them as their own single-line command.
- '!' lines are ignored; indentation defines structure.
"""

from typing import List, Tuple, Dict, Optional
from pathlib import Path
import sys

CONFIG_FILE = "sample_config"
TABSIZE = 2  # number of spaces a tab expands to


def _iter_entries(lines: List[str], tabsize: int = TABSIZE) -> List[Dict[str, object]]:
    """
    Produce structured entries:
      - indent: int (spaces after expanding tabs)
      - tokens: List[str] (content tokens)
      - next_indent: Optional[int] (indent of next kept line)
    Skips blank lines and lines that are exactly '!'.
    """
    buf: List[Dict[str, object]] = []
    for raw in lines:
        rs = raw.rstrip("\n")
        if not rs.strip():
            continue

        expanded = rs.expandtabs(tabsize)
        indent = len(expanded) - len(expanded.lstrip(" "))
        content = expanded.strip()

        if content == "!":
            continue

        tokens = content.split()
        if not tokens:
            continue

        buf.append({"indent": indent, "tokens": tokens})

    for i, ent in enumerate(buf):
        ent["next_indent"] = buf[i + 1]["indent"] if i + 1 < len(buf) else None
    return buf


def _bracket_key(tokens: List[str]) -> List[str]:
    """Return tokens with the last token wrapped in [brackets] (idempotent)."""
    if not tokens:
        return tokens
    last = tokens[-1]
    if last.startswith("[") and last.endswith("]"):
        return tokens
    return tokens[:-1] + [f"[{last}]"]


def flatten_commands(text: str, tabsize: int = TABSIZE) -> List[str]:
    """
    Convert indented blocks to flat single-line commands per rules above.
    """
    entries = _iter_entries(text.splitlines(), tabsize=tabsize)
    out: List[str] = []
    stack: List[Tuple[int, List[str]]] = []  # (indent, tokens) for group segments

    i = 0
    n = len(entries)
    while i < n:
        ent = entries[i]
        indent: int = ent["indent"]  # type: ignore[assignment]
        tokens: List[str] = ent["tokens"]  # type: ignore[assignment]
        next_indent: Optional[int] = ent["next_indent"]  # type: ignore[assignment]

        # Root-level handling: print only if it has no children; otherwise just set as root group.
        if indent == 0:
            stack.clear()
            is_group_root = (next_indent is not None and next_indent > indent)
            if is_group_root:
                # Do NOT print; just push as the root group for descendants.
                stack.append((indent, tokens))
            else:
                # Leaf at root level -> print as its own command.
                out.append(" ".join(tokens))
            i += 1
            continue

        # For non-root lines, close groups until we reach the correct parent
        while stack and stack[-1][0] >= indent:
            stack.pop()

        is_group = (next_indent is not None and next_indent > indent)
        if is_group:
            # Push and continue; emission happens when we hit leaves under this group.
            stack.append((indent, tokens))
            i += 1
            continue

        # Leaf: bundle consecutive leaves at the same indent (non-root only)
        bundle: List[str] = []
        j = i
        while j < n:
            e = entries[j]
            if e["indent"] != indent:
                break
            e_next_indent = entries[j + 1]["indent"] if j + 1 < n else None
            e_is_group = (e_next_indent is not None and e_next_indent > e["indent"])
            if e_is_group:
                break
            bundle.extend(e["tokens"])
            j += 1

        # Emit: path (groups with bracketed keys) + bundled leaf tokens
        path: List[str] = []
        for _, toks in stack:
            path.extend(_bracket_key(toks))
        line = " ".join(path + bundle)
        if line.strip():
            out.append(line)

        i = j  # continue after bundled leaves

    return out


def main() -> None:
    p = Path(CONFIG_FILE)
    if not p.exists():
        print(f'Error: "{CONFIG_FILE}" not found in the current directory.', file=sys.stderr)
        sys.exit(1)

    text = p.read_text(encoding="utf-8")
    for line in flatten_commands(text, tabsize=TABSIZE):
        print(line)


if __name__ == "__main__":
    main()
