#!/usr/bin/env python3
"""
flatten_cmds_indentation_bang_keys_py3.py

Python 3 ONLY.

Rules:
- Dynamic indentation: any increase in indentation => child of the current top.
- '!' marks the end of the most recent open item (command/subcommand).
  When closing a LEAF (an item with no children), emit a single-line command
  composed of the remaining groups' path + the leaf tokens.
- Lines with no indentation (root):
    * If they have children -> do NOT print them alone; they only act as root group.
    * If they have no children -> print them as their own command.
- Any line that has children is a "group" and its LAST token is bracketed
  in emitted paths, e.g. dns-server-a -> [dns-server-a].

Input is read from a file named "sample_config" in the current directory.
"""

from typing import List, Tuple
from pathlib import Path
import sys

CONFIG_FILE = "sample_config"

class Frame:
    __slots__ = ("indent", "tokens", "had_children")
    def __init__(self, indent: int, tokens: List[str]) -> None:
        self.indent = indent
        self.tokens = tokens
        self.had_children = False  # becomes True once a child is pushed

def _count_indent(line: str) -> int:
    """Count leading spaces (tabs expanded to 4)."""
    expanded = line.expandtabs(4)
    return len(expanded) - len(expanded.lstrip(" "))

def _is_bang(line: str) -> bool:
    return line.strip() == "!"

def _tokenize(line: str) -> List[str]:
    return line.strip().split()

def _bracket_key(tokens: List[str]) -> List[str]:
    """Bracket the last token (idempotent). For group frames only."""
    if not tokens:
        return tokens
    last = tokens[-1]
    if last.startswith("[") and last.endswith("]"):
        return tokens
    return tokens[:-1] + [f"[{last}]"]

def _emit_path(stack: List[Frame], leaf_tokens: List[str], out: List[str]) -> None:
    """Emit a single-line command: bracketed group path + leaf tokens."""
    path: List[str] = []
    for fr in stack:
        # Only bracket frames that actually had children (i.e., groups)
        if fr.had_children:
            path.extend(_bracket_key(fr.tokens))
        else:
            path.extend(fr.tokens)
    line = " ".join(path + leaf_tokens).strip()
    if line:
        out.append(line)

def flatten_commands(text: str) -> List[str]:
    """
    Streaming parse:
    - Push every non-'!' line as a frame.
    - On indent increase, mark parent.had_children = True.
    - On same or lower indent, close frames; emit if a closed frame had no children.
    - On '!' line, close one frame; emit if closed frame had no children.
    - After all lines, close remaining frames (emit leaves only).
    """
    out: List[str] = []
    stack: List[Frame] = []

    lines = [ln.rstrip("\n") for ln in text.splitlines()]
    for raw in lines:
        if not raw.strip():
            continue  # skip blanks

        if _is_bang(raw):
            # Explicit close: pop one frame; emit if it was a leaf
            if stack:
                closed = stack.pop()
                if not closed.had_children:
                    _emit_path(stack, closed.tokens, out)
            continue

        indent = _count_indent(raw)
        tokens = _tokenize(raw)
        if not tokens:
            continue

        # Implicit closes on same/lower indent
        while stack and indent <= stack[-1].indent:
            closed = stack.pop()
            if not closed.had_children:
                # Emit leaf on implicit close
                _emit_path(stack, closed.tokens, out)

        # If there is a parent now, mark it as having children
        if stack and indent > stack[-1].indent:
            stack[-1].had_children = True

        # Push the new frame
        stack.append(Frame(indent, tokens))

    # End of file: close remaining frames, emitting only leaves
    while stack:
        closed = stack.pop()
        if not closed.had_children:
            _emit_path(stack, closed.tokens, out)

    # Root rule: ensure that a root (indent==0) was only printed alone if it had no children.
    # The above logic already enforces this (groups never emit on close).

    return out

def main() -> None:
    p = Path(CONFIG_FILE)
    if not p.exists():
        print(f'Error: "{CONFIG_FILE}" not found in the current directory.', file=sys.stderr)
        sys.exit(1)
    text = p.read_text(encoding="utf-8")
    for line in flatten_commands(text):
        print(line)

if __name__ == "__main__":
    main()
